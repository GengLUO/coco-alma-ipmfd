# Hardware masking verification

This directory contains a short tutorial on how to verify a DOM-masked implementation of the AES cipher.
It should work out-of-the-box with the provided testbench. If you encounter any problems, feel free to open an issue.

## AES-DOM

AES-DOM, originally developed by Hannes Gross, is a masked implementation of the AES cipher. For this tutorial we include a fork of the original implementation in the `design` directory.
You can obtain the code by running:
```bash
cd design
git submodule init
git submodule update
```
In this tutorial, we will synthesize the circuit, generate a trace using test-vectors and then attempt to verify the probing resistance. Below, we only show a brief summary of what you need to do.

## Verification Flow

The verification flow is mostly the same as described in the root directory. However, there are additional steps
you need to perform before you can trace the execution of the circuit. In the following, we only briefly describe
the main steps.

For a simplified procedure, without any custom settings, please run `run_pipeline.py` from the virtual environment. The provided pipeline executes all the steps every time although it might not be necessary, so you can adapt it or write your own! For manual execution, please follow the following steps:

* Synthesise the `aes_top` circuit, which is the top module of the AES-DOM design. 
  Since the design was written in VHDL, which Yosys does not support natively, we have to perform a workaround. The GHDL project provides a [plugin for Yosys](https://github.com/ghdl/ghdl-yosys-plugin) that allows it to read and elaborate pure VHDL designs.
  There are multiple ways of obtaining the plugin outlined in their documentation. 
  We focus on the Docker based method. First, obtain the docker image, and then run the provided Python script to synthesize:

```bash
docker pull hdlc/ghdl:yosys
python3 synth.py
```
  The synthesis script merely automates the whole process. It prepares a custom synthesis script, runs it using the Yosys from the docker image.
  This produces a flattened verilog netlist, which you just re-synthesize with `parse.py`. The example below, saves all the data into coco-alma's temporary directory.
```bash
python3 path_to/coco-alma/parse.py --log-yosys \
    --top-module aes_top \
    --source path_to/coco-alma/examples/aes_dom/tmp/circuit.v \
    --netlist path_to/coco-alma/tmp/circuit.v
```

* Create your own Verilator testbench or use the one we provided to generate a trage. If you use the one we provided the trace is saved at `/tmp/tmp.vcd`. The example below uses the default location of the synthesized `circuit.v`.
```bash
python3 path_to/coco-alma/trace.py \
    --testbench path_to/coco-alma/examples/prince_ti/verilator_tb.cpp \
    --netlist path_to/coco-alma/tmp/circuit.v
```
* Create a labeling file for the PRINCE-TI inputs. We have provided a script that does this:
```bash
python3 generate_labels.py path_to/coco-alma/tmp/labels.txt path_to/my-labels.txt
```
* Run the verification script. In the case of our testbench, replace `path_to/vcd-file-location.vcd` with `tmp/tmp.vcd` since that is where it is generated. Provide the `--trace-stable` argument to assume that the trace generated by the circuit is stable and that no glitching occurs on the control signals. This program call verifies that there are no leaks in the first round of the cipher. For more rounds, increase the number of considered cycles.
```bash
python3 verify.py \
    --json path_to/coco-alma/tmp/circuit.json \
    --label path_to/my-labels.txt \
    --vcd path_to/vcd-file-location.vcd \
    --cycles 3 \
    --mode transient \
    --rst-name i_reset \
    --trace-stable \
    --probe-duration always
```

You can customize most of the artefact file locations generated during this process and then need to
additionally specify them as command line parameters. For more information on what options are supported,
please see the help menus available through `python parse.py --help` and similar.
